C51 COMPILER V9.05   BASELIB                                                               10/15/2012 11:41:51 PAGE 1   


C51 COMPILER V9.05, COMPILATION OF MODULE BASELIB
OBJECT MODULE PLACED IN BaseLib.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\c51.exe BaseLib.c DB OE BR INCDIR(C:\SiLabs\MCU\Inc)

line level    source

   1          #include "BaseLib.h"
   2          
   3          #define MS_VAL (0xFFFF - SYSCLK/1000)
   4          #define WORD_H(val) (((val) & 0xFF00) >> 8)
   5          #define WORD_L(val) ((val) & 0x00FF)
   6          
   7          //---------------------------------------------------------------
   8          // Initialisation globale du système
   9          //---------------------------------------------------------------
  10          void SysInit(void)
  11          {
  12   1        unsigned char i;                    // Dummy variable counters
  13   1        unsigned int k;
  14   1        
  15   1        PCA0MD = 0x00;        //pour éteindre le Watchdog
  16   1        
  17   1        OSCICN |= 0x03;                     // Set internal oscillator to highest
  18   1        // setting of 24500000
  19   1        
  20   1        while(!SDA)
  21   1        {
  22   2          // Provide clock pulses to allow the slave to advance out
  23   2          // of its current state. This will allow it to release SDA.
  24   2          XBR1 = 0x40;                     // Enable Crossbar
  25   2          SCL = 0;                         // Drive the clock low
  26   2          for(i = 0; i < 255; i++);        // Hold the clock low
  27   2          SCL = 1;                         // Release the clock
  28   2          while(!SCL);                     // Wait for open-drain
  29   2                                           // clock output to rise
  30   2          for(i = 0; i < 10; i++);         // Hold the clock high
  31   2          XBR1 = 0x00;                     // Disable Crossbar
  32   2        }
  33   1        
  34   1        Port_Init();                        // Initialize Crossbar and GPIO  
  35   1        Timer0_Init();                      // Configure Timer1 for use 
  36   1                                            // with SMBus baud rate  
  37   1        Timer3_Init ();                     // Configure Timer3 for use with
  38   1                                            // SCL low timeout detect  
  39   1        SMBus_Init ();                      // Configure and enable SMBus
  40   1        // If slave is holding SDA low because of an improper SMBus reset or error
  41   1        UART0_Init();
  42   1        EIE1 |= 0x01;                       // Enable the SMBus interrupt
  43   1        EA = 1;                             // Global interrupt enable
  44   1        
  45   1        // Initialize buffers
  46   1        for (k=0; k < SIZE_GETDATE; k++) Date[k] = ' ';
  47   1        Date[SIZE_GETDATE-1] = '\0';
  48   1        
  49   1        for (k=0; k < SIZE_GETLAT; k++)  Latitude[k] = ' ';
  50   1        Latitude[SIZE_GETLAT-1] = '\0';
  51   1        
  52   1        for (k=0; k < SIZE_GETLONG; k++) Longitude[k] = ' ';
  53   1        Longitude[SIZE_GETLONG-1] = '\0';
  54   1       
  55   1        NUM_ERRORS = 0;
C51 COMPILER V9.05   BASELIB                                                               10/15/2012 11:41:51 PAGE 2   

  56   1       
  57   1        
  58   1      }
  59          
  60          //-----------------------------------------------------------------------------
  61          // Timer0_Init()
  62          //-----------------------------------------------------------------------------
  63          //
  64          // Return Value : None
  65          // Parameters   : None
  66          //
  67          // Timer1 configured as the SMBus clock source as follows:
  68          // - Timer1 in 8-bit auto-reload mode
  69          // - SYSCLK or SYSCLK / 4 as Timer1 clock source
  70          // - Timer1 overflow rate => 3 * SMB_FREQUENCY
  71          // - The resulting SCL clock rate will be ~1/3 the Timer1 overflow rate
  72          // - Timer1 enabled
  73          //
  74          void Timer0_Init (void)
  75          {
  76   1        
  77   1        // Make sure the Timer can produce the appropriate frequency in 8-bit mode
  78   1        // Supported SMBus Frequencies range from 10kHz to 100kHz.  The CKCON register
  79   1        // settings may need to change for frequencies outside this range.
  80   1        #if ((SYSCLK/SMB_FREQUENCY/3) < 255)
                #define SCALE 1
                CKCON |= 0x04;                   // Timer0 clock source = SYSCLK
                #elif ((SYSCLK/SMB_FREQUENCY/4/3) < 255)
  84   1        #define SCALE 4
  85   1        CKCON |= 0x01;
  86   1        CKCON &= ~0x0A;                  // Timer1/0 clock source = SYSCLK / 4
  87   1        #endif
  88   1        
  89   1        TMOD = 0x02;                        // Timer0 in 8-bit auto-reload mode
  90   1        
  91   1        // Timer1 configured to overflow at 1/3 the rate defined by SMB_FREQUENCY
  92   1        TH0 = -(SYSCLK/SMB_FREQUENCY/SCALE/3);
  93   1        
  94   1        TL0 = TH0;                          // Init Timer1
  95   1        
  96   1        TR0 = 1;                            // Timer1 enabled
  97   1      }
  98          
  99          //-----------------------------------------------------------------------------
 100          // Timer3_Init
 101          //-----------------------------------------------------------------------------
 102          //
 103          // Return Value : None
 104          // Parameters   : None
 105          //
 106          // Timer3 configured for use by the SMBus low timeout detect feature as
 107          // follows:
 108          // - Timer3 in 16-bit auto-reload mode
 109          // - SYSCLK/12 as Timer3 clock source
 110          // - Timer3 reload registers loaded for a 25ms overflow period
 111          // - Timer3 pre-loaded to overflow after 25ms
 112          // - Timer3 enabled
 113          //
 114          void Timer3_Init (void)
 115          {
 116   1        TMR3CN = 0x00;                      // Timer3 configured for 16-bit auto-
 117   1                                            // reload, low-byte interrupt disabled  
C51 COMPILER V9.05   BASELIB                                                               10/15/2012 11:41:51 PAGE 3   

 118   1        CKCON &= ~0x40;                     // Timer3 uses SYSCLK/12
 119   1        TMR3RL = 0;   ;                     // Timer3 configured to overflow after ???
 120   1        TMR3 = TMR3RL;                         
 121   1        EIE1 |= 0x80;                       // Timer3 interrupt enable  
 122   1      }
 123          
 124          //-----------------------------------------------------------------------------
 125          // PORT_Init
 126          //-----------------------------------------------------------------------------
 127          //
 128          // Return Value : None
 129          // Parameters   : None
 130          //
 131          // Configure the Crossbar and GPIO ports.
 132          //
 133          // P0.0   digital   open-drain    SMBus SDA
 134          // P0.1   digital   open-drain    SMBus SCL
 135          //
 136          // P1.3   digital   push-pull     LED
 137          //
 138          // all other port pins unused
 139          //
 140          // Note: If the SMBus is moved, the SCL and SDA sbit declarations must also
 141          // be adjusted.
 142          //
 143          void PORT_Init (void)
 144          {
 145   1        P0MDOUT = 0x00;                     // All P0 pins open-drain output exept P0.6 for PWM
 146   1        P0SKIP  = 0x03;                     // Déplace le bus I2C en P0.2 et P0.3
 147   1        P1MDOUT |= 0x08;                    // Make the LED (P1.3) a push-pull output
 148   1        
 149   1        XBR0 = 0x05;                        // Enable SMBus pins & UART
 150   1        XBR1 = 0x41;                        // Enable crossbar and weak pull-ups
 151   1        
 152   1        P0 = 0xFF;
 153   1      }
 154          
 155          
 156          //-----------------------------------------------------------------------------
 157          // T0_Waitms
 158          //-----------------------------------------------------------------------------
 159          //
 160          // Return Value : None
 161          // Parameters   :
 162          //   1) unsigned char ms - number of milliseconds to wait
 163          //                        range is full range of character: 0 to 255
 164          //
 165          // Configure Timer0 to wait for <ms> milliseconds using SYSCLK as its time
 166          // base.
 167          //
 168          void T0_Waitms (unsigned int ms)
 169          {
 170   1        TCON &= ~0x30;                      // Stop Timer0; Clear TF0
 171   1        TMOD &= ~0x0f;                      // 16-bit free run mode
 172   1        TMOD |=  0x01;
 173   1        
 174   1        CKCON |= 0x04;                      // Timer0 counts SYSCLKs
 175   1        
 176   1        while (ms) {
 177   2          TR0 = 0;                         // Stop Timer0
 178   2              TH0 = WORD_H(MS_VAL);            // Overflow in 1 ms
 179   2              TL0 = WORD_L(MS_VAL);
C51 COMPILER V9.05   BASELIB                                                               10/15/2012 11:41:51 PAGE 4   

 180   2          TF0 = 0;                         // Clear overflow indicator
 181   2          TR0 = 1;                         // Start Timer0
 182   2          while (!TF0);                    // Wait for overflow
 183   2          ms--;                            // Update ms counter
 184   2        }
 185   1        
 186   1        TR0 = 0;                            // Stop Timer0
 187   1      }
 188          
 189          
 190          //-----------------------------------------------------------------------------
 191          // UART0_Init
 192          //-----------------------------------------------------------------------------
 193          //
 194          // Return Value : None
 195          // Parameters   : None
 196          //
 197          // Configure the UART0 using Timer1, for <BAUDRATE> and 8-N-1.
 198          //-----------------------------------------------------------------------------
 199          void UART0_Init (void)
 200          {
 201   1         SCON0 = 0x10;                       // SCON0: 8-bit variable bit rate
 202   1                                             //        level of STOP bit is ignored
 203   1                                             //        RX enabled
 204   1                                             //        ninth bits are zeros
 205   1                                             //        clear RI0 and TI0 bits
 206   1         if (SYSCLK/BAUDRATE/2/256 < 1) {
 207   2            TH1 = -(SYSCLK/BAUDRATE/2);
 208   2            CKCON &= ~0x0B;                  // T1M = 1; SCA1:0 = xx
 209   2            CKCON |=  0x08;
 210   2         } else if (SYSCLK/BAUDRATE/2/256 < 4) {
 211   2            TH1 = -(SYSCLK/BAUDRATE/2/4);
 212   2            CKCON &= ~0x0B;                  // T1M = 0; SCA1:0 = 01
 213   2            CKCON |=  0x01;
 214   2         } else if (SYSCLK/BAUDRATE/2/256 < 12) {
 215   2            TH1 = -(SYSCLK/BAUDRATE/2/12);
 216   2            CKCON &= ~0x0B;                  // T1M = 0; SCA1:0 = 00
 217   2         } else {
 218   2            TH1 = -(SYSCLK/BAUDRATE/2/48);
 219   2            CKCON &= ~0x0B;                  // T1M = 0; SCA1:0 = 10
 220   2            CKCON |=  0x02;
 221   2         }
 222   1      
 223   1         TL1 = TH1;                          // init Timer1
 224   1         TMOD &= ~0xf0;                      // TMOD: timer 1 in 8-bit autoreload
 225   1         TMOD |=  0x20;
 226   1         TR1 = 1;                            // START Timer1
 227   1      
 228   1         IP |= 0x10;                         // Make UART high priority
 229   1         ES0 = 1;                            // Enable UART0 interrupts
 230   1      
 231   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    235    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
C51 COMPILER V9.05   BASELIB                                                               10/15/2012 11:41:51 PAGE 5   

END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
