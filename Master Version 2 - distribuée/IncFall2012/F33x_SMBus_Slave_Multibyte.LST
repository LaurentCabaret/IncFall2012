C51 COMPILER V9.05   F33X_SMBUS_SLAVE_MULTIBYTE                                            10/08/2012 11:31:00 PAGE 1   


C51 COMPILER V9.05, COMPILATION OF MODULE F33X_SMBUS_SLAVE_MULTIBYTE
OBJECT MODULE PLACED IN F33x_SMBus_Slave_Multibyte.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\c51.exe F33x_SMBus_Slave_Multibyte.c DB OE BR INCDIR(C:\SiLabs\MCU\Inc)

line level    source

   1          //-----------------------------------------------------------------------------
   2          // F33x_SMBus_Slave_Multibyte.c
   3          //-----------------------------------------------------------------------------
   4          // Copyright 2006 Silicon Laboratories, Inc.
   5          // http://www.silabs.com
   6          //
   7          // Program Description:
   8          //
   9          // Example software to demonstrate the C8051F33x SMBus interface in Slave mode
  10          // - Interrupt-driven SMBus implementation
  11          // - Only slave states defined
  12          // - Multi-byte SMBus data holders used for both transmit and receive
  13          // - Timer1 used as SMBus clock rate (used only for free timeout detection)
  14          // - Timer3 used by SMBus for SCL low timeout detection
  15          // - ARBLOST support included
  16          // - supports multiple-byte writes and multiple-byte reads
  17          // - Pinout:
  18          //    P0.0 -> SDA (SMBus)
  19          //    P0.1 -> SCL (SMBus)
  20          //
  21          //    P1.3 -> LED
  22          //
  23          //    P2.0 -> C2D (debug interface)
  24          //
  25          //    all other port pins unused
  26          //
  27          // How To Test:
  28          //
  29          // 1) Verify that J6 is not populated.
  30          // 2) Download code to a 'F33x device that is connected to a SMBus master.
  31          // 3) Run the code.  The slave code will copy the write data to the read
  32          //    data, so a successive write and read will effectively echo the data
  33          //    written.  To verify that the code is working properly, verify on the
  34          //    master that the data received is the same as the data written.
  35          //
  36          // FID:            33X000009
  37          // Target:         C8051F33x
  38          // Tool chain:     Keil C51 7.50 / Keil EVAL C51
  39          // Command Line:   None
  40          //
  41          // Release 1.0
  42          //    -Initial Revision (TP)
  43          //    -30 MAR 2006
  44          //
  45          
  46          //-----------------------------------------------------------------------------
  47          // Includes
  48          //-----------------------------------------------------------------------------
  49          
  50          #include <C8051F330.h>
  51          #include <Protocole.h>
  52          
  53          //-----------------------------------------------------------------------------
  54          // Global Constants
  55          //-----------------------------------------------------------------------------
C51 COMPILER V9.05   F33X_SMBUS_SLAVE_MULTIBYTE                                            10/08/2012 11:31:00 PAGE 2   

  56          
  57          #define  SYSCLK         24500000       // System clock frequency in Hz
  58          
  59          #define  SMB_FREQUENCY  10000          // Target SMBus frequency
  60                                                 // This example supports between 10kHz
  61                                                 // and 100kHz
  62          
  63          #define  WRITE          0x00           // SMBus WRITE command
  64          #define  READ           0x01           // SMBus READ command
  65          
  66          #define  SLAVE_ADDR     0xF0           // Device addresses (7 bits,
  67                                                 // lsb is a don't care)
  68          
  69          // Status vector - top 4 bits only
  70          #define  SMB_SRADD      0x20           // (SR) slave address received
  71                                                 //    (also could be a lost
  72                                                 //    arbitration)
  73          #define  SMB_SRSTO      0x10           // (SR) STOP detected while SR or ST,
  74                                                 //    or lost arbitration
  75          #define  SMB_SRDB       0x00           // (SR) data byte received, or
  76                                                 //    lost arbitration
  77          #define  SMB_STDB       0x40           // (ST) data byte transmitted
  78          #define  SMB_STSTO      0x50           // (ST) STOP detected during a
  79                                                 //    transaction; bus error
  80          // End status vector definition
  81          
  82          #define  NUM_BYTES_WR   1              // Number of bytes to write
  83                                                 // Slave <- Master
  84          #define  NUM_BYTES_RD   320              // Number of bytes to read
  85                                                 // Slave -> Master
  86          
  87          #define SYSTEMCLOCK 25000000
  88          #define BAUDRATE        9600           // Baud rate of UART in bps
  89          
  90          //-----------------------------------------------------------------------------
  91          // Global VARIABLES
  92          //-----------------------------------------------------------------------------
  93          
  94          // Global holder for SMBus data.
  95          // All receive data is written here
  96          // NUM_BYTES_WR used because an SMBus write is Master->Slave
  97          xdata unsigned char SMB_DATA_IN[NUM_BYTES_WR];
  98          
  99          // Global holder for SMBus data.
 100          // All transmit data is read from here
 101          // NUM_BYTES_RD used because an SMBus read is Slave->Master
 102          xdata unsigned char SMB_DATA_OUT[NUM_BYTES_RD];
 103          
 104          bit DATA_READY = 0;                    // Set to '1' by the SMBus ISR
 105                                                 // when a new data byte has been
 106                                                 // received.
 107          unsigned int DataToSend;
 108          
 109          // 16-bit SFR declarations
 110          sfr16    TMR3RL   = 0x92;              // Timer3 reload registers
 111          sfr16    TMR3     = 0x94;              // Timer3 counter registers
 112          
 113          sbit LED = P1^3;                       // LED on port P1.3
 114          
 115          //-----------------------------------------------------------------------------
 116          // Function PROTOTYPES
 117          //-----------------------------------------------------------------------------
C51 COMPILER V9.05   F33X_SMBUS_SLAVE_MULTIBYTE                                            10/08/2012 11:31:00 PAGE 3   

 118          
 119          void SMBus_Init (void);
 120          void Timer0_Init (void);
 121          void Timer3_Init (void);
 122          void Port_Init (void);
 123          
 124          void SMBus_ISR (void);
 125          void Timer3_ISR (void);
 126          void UART0_Init(void);
 127          void SysInit(void);
 128          
 129          //-----------------------------------------------------------------------------
 130          // MAIN Routine
 131          //-----------------------------------------------------------------------------
 132          //
 133          // Main routine performs all configuration tasks, then waits for SMBus
 134          // communication.
 135          //
 136          void main (void)
 137          {
 138   1         unsigned long i;
 139   1         unsigned long part = 0;
 140   1         SysInit();
 141   1         // Initialize the outgoing data array in case a read is done before a
 142   1         // write
 143   1        /* for (i = 0; i < NUM_BYTES_RD; i++)
 144   1         {
 145   1            SMB_DATA_OUT[i] = 0xFD;
 146   1         }*/
 147   1      
 148   1         while(1)
 149   1         {
 150   2            while(!DATA_READY);              // New SMBus data received?
 151   2            DATA_READY = 0;
 152   2      
 153   2      
 154   2      
 155   2      
 156   2                    if (SMB_DATA_IN[0]==CMD_GETDATE) {
 157   3                    // Copy the data from the input array to the output array
 158   3                        DataToSend = SIZE_GETDATE;
 159   3                SMB_DATA_OUT[0] = '1';
 160   3                SMB_DATA_OUT[1] = '2';
 161   3                SMB_DATA_OUT[2] = '0';
 162   3                SMB_DATA_OUT[3] = '3';
 163   3                SMB_DATA_OUT[4] = '2';
 164   3                SMB_DATA_OUT[5] = '0';
 165   3                SMB_DATA_OUT[6] = '1';
 166   3                SMB_DATA_OUT[7] = '2';
 167   3                SMB_DATA_OUT[8] = '_';
 168   3                SMB_DATA_OUT[9] = '1';
 169   3                SMB_DATA_OUT[10] = '2';
 170   3                SMB_DATA_OUT[11] = ':';
 171   3                SMB_DATA_OUT[12] = '4';
 172   3                SMB_DATA_OUT[13] = '2';
 173   3                SMB_DATA_OUT[14] = ':';
 174   3                SMB_DATA_OUT[15] = '3';
 175   3                SMB_DATA_OUT[16] = '6';
 176   3                SMB_DATA_OUT[17] = '\0';
 177   3                        LED =1;
 178   3                      }
 179   2      
C51 COMPILER V9.05   F33X_SMBUS_SLAVE_MULTIBYTE                                            10/08/2012 11:31:00 PAGE 4   

 180   2      
 181   2            if (SMB_DATA_IN[0]==CMD_GETID) { // GetID
 182   3                    // Copy the data from the input array to the output array
 183   3                        DataToSend = 1;
 184   3                SMB_DATA_OUT[0] = 42; //l'ID de ce module caméra
 185   3                        LED =1;
 186   3                      }
 187   2      
 188   2            if (SMB_DATA_IN[0]==CMD_STARTCONSO) { // StartConso
 189   3                    // Copy the data from the input array to the output array
 190   3                        LED =0;
 191   3                      }
 192   2      
 193   2            if (SMB_DATA_IN[0]== CMD_STOPCONSO) { // StopConso
 194   3                    // Copy the data from the input array to the output array
 195   3                        LED =1;
 196   3                      }
 197   2      
 198   2            if (SMB_DATA_IN[0]==CMD_GETLAT) { // GetLat
 199   3                    // Copy the data from the input array to the output array
 200   3                        DataToSend = 7;
 201   3                SMB_DATA_OUT[0] = '4'; //
 202   3                SMB_DATA_OUT[1] = '8'; //
 203   3                SMB_DATA_OUT[2] = '.'; //
 204   3                SMB_DATA_OUT[3] = '7'; //
 205   3                SMB_DATA_OUT[4] = '6'; //
 206   3                SMB_DATA_OUT[5] = '5'; //
 207   3                SMB_DATA_OUT[6] = '3'; //
 208   3                SMB_DATA_OUT[7] = '\0';
 209   3                        LED =1;
 210   3      //                48.765351,2.288409  --> Bat Ens
 211   3                      }
 212   2      
 213   2            if (SMB_DATA_IN[0]==CMD_GETLONG) { // GetLong
 214   3                    // Copy the data from the input array to the output array
 215   3                        DataToSend = 7;
 216   3                SMB_DATA_OUT[0] = '0'; //
 217   3                SMB_DATA_OUT[1] = '2'; //
 218   3                SMB_DATA_OUT[2] = '.'; //
 219   3                SMB_DATA_OUT[3] = '2'; //
 220   3                SMB_DATA_OUT[4] = '8'; //
 221   3                SMB_DATA_OUT[5] = '8'; //
 222   3                SMB_DATA_OUT[6] = '4'; //
 223   3                SMB_DATA_OUT[7] = '\0';
 224   3                        LED =1;
 225   3              }
 226   2      
 227   2         }
 228   1      }
*** WARNING C280 IN LINE 138 OF F33x_SMBus_Slave_Multibyte.c: 'i': unreferenced local variable
 229          
 230          //-----------------------------------------------------------------------------
 231          // Initialization Routines
 232          //-----------------------------------------------------------------------------
 233          
 234          //-----------------------------------------------------------------------------
 235          // SMBus_Init()
 236          //-----------------------------------------------------------------------------
 237          //
 238          // Return Value : None
 239          // Parameters   : None
 240          //
C51 COMPILER V9.05   F33X_SMBUS_SLAVE_MULTIBYTE                                            10/08/2012 11:31:00 PAGE 5   

 241          // SMBus configured as follows:
 242          // - SMBus enabled
 243          // - Slave mode not inhibited
 244          // - Timer1 used as clock source. The maximum SCL frequency will be
 245          //   approximately 1/3 the Timer1 overflow rate
 246          // - Setup and hold time extensions enabled
 247          // - Bus Free and SCL Low timeout detection enabled
 248          //
 249          void SMBus_Init (void)
 250          {
 251   1         SMB0CF = 0x1D;                      // Use Timer1 overflows as SMBus clock
 252   1                                             // source;
 253   1                                             // Enable slave mode;
 254   1                                             // Enable setup & hold time
 255   1                                             // extensions;
 256   1                                             // Enable SMBus Free timeout detect;
 257   1                                             // Enable SCL low timeout detect;
 258   1      
 259   1         SMB0CF |= 0x80;                     // Enable SMBus;
 260   1      }
 261          
 262          //-----------------------------------------------------------------------------
 263          // Timer1_Init()
 264          //-----------------------------------------------------------------------------
 265          //
 266          // Return Value : None
 267          // Parameters   : None
 268          //
 269          // Timer1 configured as the SMBus clock source as follows:
 270          // - Timer1 in 8-bit auto-reload mode
 271          // - SYSCLK or SYSCLK / 4 as Timer1 clock source
 272          // - Timer1 overflow rate => 3 * SMB_FREQUENCY
 273          // - The resulting SCL clock rate will be ~1/3 the Timer1 overflow rate
 274          // - Timer1 enabled
 275          //
 276          void Timer0_Init (void)
 277          {
 278   1      
 279   1      // Make sure the Timer can produce the appropriate frequency in 8-bit mode
 280   1      // Supported SMBus Frequencies range from 10kHz to 100kHz.  The CKCON register
 281   1      // settings may need to change for frequencies outside this range.
 282   1      #if ((SYSCLK/SMB_FREQUENCY/3) < 255)
                 #define SCALE 1
                    CKCON |= 0x04;                   // Timer0 clock source = SYSCLK
              #elif ((SYSCLK/SMB_FREQUENCY/4/3) < 255)
 286   1         #define SCALE 4
 287   1            CKCON |= 0x01;
 288   1            CKCON &= ~0x0A;                  // Timer1/0 clock source = SYSCLK / 4
 289   1      #endif
 290   1      
 291   1         TMOD = 0x02;                        // Timer0 in 8-bit auto-reload mode
 292   1      
 293   1         // Timer1 configured to overflow at 1/3 the rate defined by SMB_FREQUENCY
 294   1         TH0 = -(SYSCLK/SMB_FREQUENCY/SCALE/3);
 295   1      
 296   1         TL0 = TH0;                          // Init Timer1
 297   1      
 298   1         TR0 = 1;                            // Timer1 enabled
 299   1      }
 300          
 301          //-----------------------------------------------------------------------------
 302          // Timer3_Init()
C51 COMPILER V9.05   F33X_SMBUS_SLAVE_MULTIBYTE                                            10/08/2012 11:31:00 PAGE 6   

 303          //-----------------------------------------------------------------------------
 304          //
 305          // Return Value : None
 306          // Parameters   : None
 307          //
 308          // Timer3 configured for use by the SMBus low timeout detect feature as
 309          // follows:
 310          // - Timer3 in 16-bit auto-reload mode
 311          // - SYSCLK/12 as Timer3 clock source
 312          // - Timer3 reload registers loaded for a 25ms overflow period
 313          // - Timer3 pre-loaded to overflow after 25ms
 314          // - Timer3 enabled
 315          //
 316          void Timer3_Init (void)
 317          {
 318   1         TMR3CN = 0x00;                      // Timer3 configured for 16-bit auto-
 319   1                                             // reload, low-byte interrupt disabled
 320   1      
 321   1         CKCON &= ~0x40;                     // Timer3 uses SYSCLK/12
 322   1      
 323   1         TMR3RL = -(SYSCLK/12/40);           // Timer3 configured to overflow after
 324   1         TMR3 = TMR3RL;                      // ~25ms (for SMBus low timeout detect):
 325   1                                             // 1/.025 = 40
 326   1      
 327   1         EIE1 |= 0x80;                       // Timer3 interrupt enable
 328   1         TMR3CN |= 0x04;                     // Start Timer3
 329   1      }
 330          
 331          //-----------------------------------------------------------------------------
 332          // PORT_Init
 333          //-----------------------------------------------------------------------------
 334          //
 335          // Return Value : None
 336          // Parameters   : None
 337          //
 338          // Configure the Crossbar and GPIO ports.
 339          //
 340          // P0.0   digital   open-drain    SMBus SDA
 341          // P0.1   digital   open-drain    SMBus SCL
 342          //
 343          // P1.3   digital   push-pull     LED
 344          //
 345          // all other port pins unused
 346          //
 347          void PORT_Init (void)
 348          {
 349   1         P0MDOUT = 0x50;                     // All P0 pins open-drain output exept P0.6 for PWM
 350   1         P0SKIP = 0x03;
 351   1         P1MDOUT |= 0x08;                    // Make the LED (P1.3) a push-pull (powerfull)
 352   1                                             // output
 353   1      
 354   1         XBR0 = 0x05;                        // Enable SMBus pins & UART
 355   1         XBR1 = 0x41;                        // Enable crossbar and weak pull-ups and PWM
 356   1      
 357   1         P0 = 0xFF;
 358   1      }
 359          
 360          
 361          
 362          //-----------------------------------------------------------------------------
 363          // Interrupt Service Routines
 364          //-----------------------------------------------------------------------------
C51 COMPILER V9.05   F33X_SMBUS_SLAVE_MULTIBYTE                                            10/08/2012 11:31:00 PAGE 7   

 365          
 366          //-----------------------------------------------------------------------------
 367          // SMBus Interrupt Service Routine (ISR)
 368          //-----------------------------------------------------------------------------
 369          //
 370          // SMBus ISR state machine
 371          // - Slave only implementation - no master states defined
 372          // - All incoming data is written to global variable <SMB_data_IN>
 373          // - All outgoing data is read from global variable <SMB_data_OUT>
 374          //
 375          void SMBus_ISR (void) interrupt 7
 376          {
 377   1         static unsigned int sent_byte_counter;
 378   1         static unsigned int rec_byte_counter;
 379   1      
 380   1         if (ARBLOST == 0)
 381   1         {
 382   2            switch (SMB0CN & 0xF0)           // Decode the SMBus status vector
 383   2            {
 384   3               // Slave Receiver: Start+Address received
 385   3               case  SMB_SRADD:
 386   3      
 387   3                  STA = 0;                   // Clear STA bit
 388   3      
 389   3                  sent_byte_counter = 1;     // Reinitialize the data counters
 390   3                  rec_byte_counter = 1;
 391   3      
 392   3                  if((SMB0DAT&0xFE) == (SLAVE_ADDR&0xFE)) // Decode address
 393   3                  {                          // If the received address matches,
 394   4                     ACK = 1;                // ACK the received slave address
 395   4      
 396   4                     if((SMB0DAT&0x01) == READ) // If the transfer is a master READ,
 397   4                     {
 398   5                        // Prepare outgoing byte
 399   5                        SMB0DAT = SMB_DATA_OUT[sent_byte_counter-1];
 400   5                        sent_byte_counter++;
 401   5                     }
 402   4                  }
 403   3                  else                       // If received slave address does not
 404   3                  {                          // match,
 405   4                     ACK = 0;                // NACK received address
 406   4                  }
 407   3                  break;
 408   3      
 409   3               // Slave Receiver: Data received
 410   3               case  SMB_SRDB:
 411   3      
 412   3                  if (rec_byte_counter < NUM_BYTES_WR)
 413   3                  {
 414   4                     // Store incoming data
 415   4                     SMB_DATA_IN[rec_byte_counter-1] = SMB0DAT;
 416   4                     rec_byte_counter++;
 417   4      
 418   4                     ACK = 1;                // ACK received data
 419   4                  }
 420   3                  else
 421   3                  {
 422   4                     // Store incoming data
 423   4                     SMB_DATA_IN[rec_byte_counter-1] = SMB0DAT;
 424   4      
 425   4                     DATA_READY = 1;         // Indicate new data fully received
 426   4                     ACK = 1;                // ACK received data
C51 COMPILER V9.05   F33X_SMBUS_SLAVE_MULTIBYTE                                            10/08/2012 11:31:00 PAGE 8   

 427   4                  }
 428   3      
 429   3                  break;
 430   3      
 431   3               // Slave Receiver: Stop received while either a Slave Receiver or
 432   3               // Slave Transmitter
 433   3               case  SMB_SRSTO:
 434   3      
 435   3                  STO = 0;                   // STO must be cleared by software when
 436   3                                             // a STOP is detected as a slave
 437   3                  break;
 438   3      
 439   3               // Slave Transmitter: Data byte transmitted
 440   3               case  SMB_STDB:
 441   3      
 442   3                  if (ACK == 1)              // If Master ACK's, send the next byte
 443   3                  {
 444   4                     if (sent_byte_counter <= DataToSend)
 445   4                     {
 446   5                        // Prepare next outgoing byte
 447   5                        SMB0DAT = SMB_DATA_OUT[sent_byte_counter-1];
 448   5                        sent_byte_counter++;
 449   5                     }
 450   4                  }                          // Otherwise, do nothing
 451   3                  break;
 452   3      
 453   3               // Slave Transmitter: Arbitration lost, Stop detected
 454   3               //
 455   3               // This state will only be entered on a bus error condition.
 456   3               // In normal operation, the slave is no longer sending data or has
 457   3               // data pending when a STOP is received from the master, so the TXMODE
 458   3               // bit is cleared and the slave goes to the SRSTO state.
 459   3               case  SMB_STSTO:
 460   3      
 461   3                  STO = 0;                   // STO must be cleared by software when
 462   3                                             // a STOP is detected as a slave
 463   3                  break;
 464   3      
 465   3               // Default: all other cases undefined
 466   3               default:
 467   3      
 468   3                  SMB0CF &= ~0x80;           // Reset communication
 469   3                  SMB0CF |= 0x80;
 470   3                  STA = 0;
 471   3                  STO = 0;
 472   3                  ACK = 0;
 473   3                  break;
 474   3            }
 475   2         }
 476   1         // ARBLOST = 1, Abort failed transfer
 477   1         else
 478   1         {
 479   2            STA = 0;
 480   2            STO = 0;
 481   2            ACK = 0;
 482   2         }
 483   1      
 484   1         SI = 0;                             // Clear SMBus interrupt flag
 485   1      }
 486          
 487          //-----------------------------------------------------------------------------
 488          // Timer3 Interrupt Service Routine (ISR)
C51 COMPILER V9.05   F33X_SMBUS_SLAVE_MULTIBYTE                                            10/08/2012 11:31:00 PAGE 9   

 489          //-----------------------------------------------------------------------------
 490          //
 491          // A Timer3 interrupt indicates an SMBus SCL low timeout.
 492          // The SMBus is disabled and re-enabled here
 493          //
 494          void Timer3_ISR (void) interrupt 14
 495          {
 496   1         SMB0CF &= ~0x80;                    // Disable SMBus
 497   1         SMB0CF |= 0x80;                     // Re-enable SMBus
 498   1         TMR3CN &= ~0x80;                    // Clear Timer3 interrupt-pending flag
 499   1      }
 500          
 501          
 502          //-----------------------------------------------------------------------------
 503          // UART0_Init
 504          //-----------------------------------------------------------------------------
 505          //
 506          // Return Value : None
 507          // Parameters   : None
 508          //
 509          // Configure the UART0 using Timer1, for <BAUDRATE> and 8-N-1.
 510          //-----------------------------------------------------------------------------
 511          void UART0_Init (void)
 512          {
 513   1         SCON0 = 0x10;                       // SCON0: 8-bit variable bit rate
 514   1                                             //        level of STOP bit is ignored
 515   1                                             //        RX enabled
 516   1                                             //        ninth bits are zeros
 517   1                                             //        clear RI0 and TI0 bits
 518   1         if (SYSTEMCLOCK/BAUDRATE/2/256 < 1) {
 519   2            TH1 = -(SYSTEMCLOCK/BAUDRATE/2);
 520   2            CKCON &= ~0x0B;                  // T1M = 1; SCA1:0 = xx
 521   2            CKCON |=  0x08;
 522   2         } else if (SYSTEMCLOCK/BAUDRATE/2/256 < 4) {
 523   2            TH1 = -(SYSTEMCLOCK/BAUDRATE/2/4);
 524   2            CKCON &= ~0x0B;                  // T1M = 0; SCA1:0 = 01
 525   2            CKCON |=  0x01;
 526   2         } else if (SYSTEMCLOCK/BAUDRATE/2/256 < 12) {
 527   2            TH1 = -(SYSTEMCLOCK/BAUDRATE/2/12);
 528   2            CKCON &= ~0x0B;                  // T1M = 0; SCA1:0 = 00
 529   2         } else {
 530   2            TH1 = -(SYSTEMCLOCK/BAUDRATE/2/48);
 531   2            CKCON &= ~0x0B;                  // T1M = 0; SCA1:0 = 10
 532   2            CKCON |=  0x02;
 533   2         }
 534   1      
 535   1         TL1 = TH1;                          // init Timer1
 536   1         TMOD &= ~0xf0;                      // TMOD: timer 1 in 8-bit autoreload
 537   1         TMOD |=  0x20;
 538   1         TR1 = 1;                            // START Timer1
 539   1      
 540   1         IP |= 0x10;                         // Make UART high priority
 541   1         ES0 = 1;                            // Enable UART0 interrupts
 542   1      
 543   1      }
 544          
 545          
 546          //---------------------------------------------------------------
 547          // Initialisation gloable du système
 548          //---------------------------------------------------------------
 549          void SysInit(void)
 550          {
C51 COMPILER V9.05   F33X_SMBUS_SLAVE_MULTIBYTE                                            10/08/2012 11:31:00 PAGE 10  

 551   1         PCA0MD = 0x00;       //pour éteindre le Watchdog
 552   1      
 553   1         OSCICN |= 0x03;                     // Set internal oscillator to highest
 554   1                                             // setting of 24500000
 555   1      
 556   1         Port_Init();                        // Initialize Crossbar and GPIO
 557   1      
 558   1      //   PWM_init();                //Initialisation du périphérique PWM
 559   1      
 560   1         Timer0_Init();                      // Configure Timer1 for use
 561   1                                             // with SMBus baud rate
 562   1      
 563   1         Timer3_Init ();                     // Configure Timer3 for use with
 564   1                                             // SCL low timeout detect
 565   1      
 566   1         SMBus_Init ();                      // Configure and enable SMBus
 567   1      
 568   1         UART0_Init();
 569   1      
 570   1         EIE1 |= 0x01;                       // Enable the SMBus interrupt
 571   1      
 572   1         LED = 0;
 573   1      
 574   1         EA = 1;                             // Global interrupt enable
 575   1      }
 576          
 577          //-----------------------------------------------------------------------------
 578          // End Of File
 579          //-----------------------------------------------------------------------------


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    602    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    321    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      6       8
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
