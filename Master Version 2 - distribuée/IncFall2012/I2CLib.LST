C51 COMPILER V9.05   I2CLIB                                                                10/15/2012 11:41:50 PAGE 1   


C51 COMPILER V9.05, COMPILATION OF MODULE I2CLIB
OBJECT MODULE PLACED IN I2CLib.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\c51.exe I2CLib.c DB OE BR INCDIR(C:\SiLabs\MCU\Inc)

line level    source

   1          #include "I2CLib.h"
   2          
   3          //-----------------------------------------------------------------------------
   4          // Global VARIABLES
   5          //-----------------------------------------------------------------------------
   6          
   7          // Global holder for SMBus data
   8          // All receive data is written here
   9          xdata unsigned char SMB_DATA_IN[NUM_BYTES_RD];
  10          
  11          // Global holder for SMBus data.
  12          // All transmit data is read from here
  13          xdata unsigned char SMB_DATA_OUT[NUM_BYTES_WR];
  14          
  15          unsigned char TARGET;                  // Target SMBus slave address
  16          
  17          bit SMB_BUSY;                          // Software flag to indicate when the
  18                                                 // SMB_Read() or SMB_Write() functions
  19                                                 // have claimed the SMBus
  20          
  21          bit SMB_RW;                            // Software flag to indicate the
  22                                                 // direction of the current transfer
  23          //bit SMB_TIMEOUT;                       // Software flag to indicate SMBus
  24                                                 // communication timeout
  25          
  26          //unsigned long NUM_ERRORS = 0;          // Counter for the number of errors.
  27          
  28          unsigned int ByteRequested;
  29          
  30          // Counter for the number of communication error with the salve module (SMBus)
  31          unsigned long NUM_ERRORS;
  32          // Software flag to indicate timeout during the last SMBus communication
  33          bit SMB_TIMEOUT;
  34          
  35          
  36          
  37          //-----------------------------------------------------------------------------
  38          // Initialization Routines
  39          //-----------------------------------------------------------------------------
  40          
  41          //-----------------------------------------------------------------------------
  42          // SMBus_Init
  43          //-----------------------------------------------------------------------------
  44          //
  45          // Return Value : None
  46          // Parameters   : None
  47          //
  48          // SMBus configured as follows:
  49          // - SMBus enabled
  50          // - Slave mode inhibited
  51          // - Timer1 used as clock source. The maximum SCL frequency will be
  52          //   approximately 1/3 the Timer1 overflow rate
  53          // - Setup and hold time extensions enabled
  54          // - Bus Free and SCL Low timeout detection enabled
  55          //
C51 COMPILER V9.05   I2CLIB                                                                10/15/2012 11:41:50 PAGE 2   

  56          void SMBus_Init (void)
  57          {
  58   1         SMB0CF = 0x55;                      // Use Timer1 overflows as SMBus clock
  59   1                                             // source;
  60   1                                             // Disable slave mode;
  61   1                                             // Enable setup & hold time
  62   1                                             // extensions;
  63   1                                             // Enable SMBus Free timeout detect;
  64   1      
  65   1         SMB0CF |= 0x80;                     // Enable SMBus;
  66   1      }
  67          
  68          
  69          
  70          
  71          //-----------------------------------------------------------------------------
  72          // Interrupt Service Routines
  73          //-----------------------------------------------------------------------------
  74          
  75          //-----------------------------------------------------------------------------
  76          // SMBus Interrupt Service Routine (ISR)
  77          //-----------------------------------------------------------------------------
  78          //
  79          // SMBus ISR state machine
  80          // - Master only implementation - no slave or arbitration states defined
  81          // - All incoming data is written to global variable array <SMB_DATA_IN>
  82          // - All outgoing data is read from global variable array <SMB_DATA_OUT>
  83          //
  84          void SMBus_ISR (void) interrupt 7
  85          {
  86   1         bit FAIL = 0;                       // Used by the ISR to flag failed
  87   1                                             // transfers
  88   1      
  89   1         static unsigned int sent_byte_counter;
  90   1         static unsigned int rec_byte_counter;
  91   1      
  92   1         if (ARBLOST == 0)                   // Check for errors
  93   1         {
  94   2            // Normal operation
  95   2            switch (SMB0CN & 0xF0)           // Status vector
  96   2            {
  97   3               // Master Transmitter/Receiver: START condition transmitted.
  98   3               case SMB_MTSTA:
  99   3                  SMB0DAT = TARGET;          // Load address of the target slave
 100   3                  SMB0DAT &= 0xFE;           // Clear the LSB of the address for the
 101   3                                             // R/W bit
 102   3                  SMB0DAT |= SMB_RW;         // Load R/W bit
 103   3                  STA = 0;                   // Manually clear START bit
 104   3                  rec_byte_counter = 1;      // Reset the counter
 105   3                  sent_byte_counter = 1;     // Reset the counter
 106   3                  break;
 107   3      
 108   3               // Master Transmitter: Data byte transmitted
 109   3               case SMB_MTDB:
 110   3                  if (ACK)                   // Slave ACK?
 111   3                  {
 112   4                     if (SMB_RW == WRITE)    // If this transfer is a WRITE,
 113   4                     {
 114   5                        if (sent_byte_counter <= NUM_BYTES_WR)
 115   5                        {
 116   6                           // send data byte
 117   6                           SMB0DAT = SMB_DATA_OUT[sent_byte_counter-1];
C51 COMPILER V9.05   I2CLIB                                                                10/15/2012 11:41:50 PAGE 3   

 118   6                           sent_byte_counter++;
 119   6                        }
 120   5                        else
 121   5                        {
 122   6                           STO = 1;          // Set STO to terminate transfer
 123   6                           SMB_BUSY = 0;     // And free SMBus interface
 124   6                        }
 125   5                     }
 126   4                     else {}                 // If this transfer is a READ,
 127   4                                             // proceed with transfer without
 128   4                                             // writing to SMB0DAT (switch
 129   4                                             // to receive mode)
 130   4      
 131   4      
 132   4                  }
 133   3                  else                       // If slave NACK,
 134   3                  {
 135   4                     STO = 1;                // Send STOP condition, followed
 136   4                     STA = 1;                // By a START
 137   4                     NUM_ERRORS++;           // Indicate error
 138   4                  }
 139   3                  break;
 140   3      
 141   3               // Master Receiver: byte received
 142   3               case SMB_MRDB:
 143   3                  if (rec_byte_counter < ByteRequested)
 144   3                  {
 145   4                     SMB_DATA_IN[rec_byte_counter-1] = SMB0DAT; // Store received
 146   4                                                               // byte
 147   4                     ACK = 1;                 // Send ACK to indicate byte received
 148   4                     rec_byte_counter++;      // Increment the byte counter
 149   4                  }
 150   3                  else
 151   3                  {
 152   4                     SMB_DATA_IN[rec_byte_counter-1] = SMB0DAT; // Store received
 153   4                                                               // byte
 154   4                     SMB_BUSY = 0;            // Free SMBus interface
 155   4                     ACK = 0;                 // Send NACK to indicate last byte
 156   4                                             // of this transfer
 157   4      
 158   4                     STO = 1;                 // Send STOP to terminate transfer
 159   4                                 TMR3CN &= 0xF9;          // Stop timeout timer
 160   4                  }
 161   3                  break;
 162   3      
 163   3               default:
 164   3                  FAIL = 1;                  // Indicate failed transfer
 165   3                                             // and handle at end of ISR
 166   3                  break;
 167   3      
 168   3            } // end switch
 169   2         }
 170   1         else
 171   1         {
 172   2            // ARBLOST = 1, error occurred... abort transmission
 173   2            FAIL = 1;
 174   2         } // end ARBLOST if
 175   1      
 176   1         if (FAIL)                           // If the transfer failed,
 177   1         {
 178   2            SMB0CF &= ~0x80;                 // Reset communication
 179   2            SMB0CF |= 0x80;
C51 COMPILER V9.05   I2CLIB                                                                10/15/2012 11:41:50 PAGE 4   

 180   2            STA = 0;
 181   2            STO = 0;
 182   2            ACK = 0;
 183   2      
 184   2            SMB_BUSY = 0;                    // Free SMBus
 185   2      
 186   2            FAIL = 0;
 187   2      //      LED = 0;
 188   2      
 189   2            NUM_ERRORS++;                    // Indicate an error occurred
 190   2         }
 191   1      
 192   1         SI = 0;                             // Clear interrupt flag
 193   1      }
 194          
 195          //-----------------------------------------------------------------------------
 196          // Timer3 Interrupt Service Routine (ISR)
 197          //-----------------------------------------------------------------------------
 198          //
 199          // A Timer3 interrupt indicates an SMBus SCL low timeout.
 200          // The SMBus is disabled and re-enabled here
 201          //
 202          void Timer3_ISR (void) interrupt 14
 203          {
 204   1         SMB0CF &= ~0x80;                    // Disable SMBus
 205   1         SMB0CF |= 0x80;                     // Re-enable SMBus
 206   1         TMR3CN &= ~0x80;                    // Clear Timer3 interrupt-pending
 207   1                                             // flag
 208   1         STA = 0;
 209   1         SMB_BUSY = 0;                       // Free SMBus
 210   1         SMB_TIMEOUT = 1;
 211   1      }
 212          
 213          //-----------------------------------------------------------------------------
 214          // Support Functions
 215          //-----------------------------------------------------------------------------
 216          
 217          //-----------------------------------------------------------------------------
 218          // SMB_Write
 219          //-----------------------------------------------------------------------------
 220          //
 221          // Return Value : None
 222          // Parameters   : None
 223          //
 224          // Writes a single byte to the slave with address specified by the <TARGET>
 225          // variable.
 226          // Calling sequence:
 227          // 1) Write target slave address to the <TARGET> variable
 228          // 2) Write outgoing data to the <SMB_DATA_OUT> variable array
 229          // 3) Call SMB_Write()
 230          //
 231          void SMB_Write (void)
 232          {
 233   1         while (SMB_BUSY);                   // Wait for SMBus to be free.
 234   1         SMB_BUSY = 1;                       // Claim SMBus (set to busy)
 235   1         SMB_RW = 0;                         // Mark this transfer as a WRITE
 236   1         STA = 1;                            // Start transfer
 237   1      
 238   1         //TMR3 = TMR3RL;                      // Set Timeout counter to ~25ms
 239   1         //TMR3CN |= 0x04;                     // Start Timeout counter
 240   1      }
 241          
C51 COMPILER V9.05   I2CLIB                                                                10/15/2012 11:41:50 PAGE 5   

 242          //-----------------------------------------------------------------------------
 243          // SMB_Read
 244          //-----------------------------------------------------------------------------
 245          //
 246          // Return Value : None
 247          // Parameters   : None
 248          //
 249          // Reads a single byte from the slave with address specified by the <TARGET>
 250          // variable.
 251          // Calling sequence:
 252          // 1) Write target slave address to the <TARGET> variable
 253          // 2) Call SMB_Write()
 254          // 3) Read input data from <SMB_DATA_IN> variable array
 255          //
 256          void SMB_Read (void)
 257          {
 258   1         while (SMB_BUSY);                   // Wait for bus to be free.
 259   1         SMB_BUSY = 1;                       // Claim SMBus (set to busy)
 260   1         SMB_RW = 1;                         // Mark this transfer as a READ
 261   1      
 262   1         STA = 1;                            // Start transfer
 263   1      
 264   1         //TMR3 = TMR3RL;                      // Set Timeout counter to ~25ms
 265   1         //TMR3CN |= 0x04;                     // Start Timeout counter
 266   1      
 267   1         while (SMB_BUSY);                   // Wait for transfer to complete
 268   1      }
 269          
 270          
 271          
 272          
 273          
 274          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    306    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     14    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     11    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
